"""
Knitout File Diff Tool: Generated by CLaude AI

A Python module for comparing knitout (.k) files with semantic understanding
of the knitout format. This tool provides Git-style diffs while ignoring
insignificant differences like comments and whitespace variations.

Based on the knitout specification: https://textiles-lab.github.io/knitout/knitout.html

Author: Assistant
Date: 2025
"""

import difflib
from dataclasses import dataclass
from enum import Enum

from knitout_interpreter.knitout_language.Knitout_Parser import parse_knitout
from knitout_interpreter.knitout_operations.Header_Line import Knitout_Header_Line, Knitout_Header_Line_Type
from knitout_interpreter.knitout_operations.Knitout_Line import Knitout_Line, Knitout_Version_Line, Knitout_Comment_Line
from knitout_interpreter.knitout_operations.Rack_Instruction import Rack_Instruction
from knitout_interpreter.knitout_operations.carrier_instructions import Yarn_Carrier_Instruction
from knitout_interpreter.knitout_operations.knitout_instruction import Knitout_Instruction, Knitout_Instruction_Type
from knitout_interpreter.knitout_operations.needle_instructions import Needle_Instruction, Xfer_Instruction
from virtual_knitting_machine.machine_components.needles.Needle import Needle


class DiffType(Enum):
    """Types of differences that can be found between knitout files."""
    HEADER = "header"
    OPERATION = "operation"
    STRUCTURE = "structure"

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return self.name

    def __hash__(self) -> int:
        return hash(self.name)


@dataclass
class Knitout_Diff_Line:
    """
    Represents a parsed line from a knitout file.

    Attributes:
        instruction: The parsed Knitout Line.
        line_number: Original line number in the file.
    """
    instruction: Knitout_Line
    line_number: int

    def get_normalized_string(self, ignore_comments: bool = False) -> str:
        """Get a normalized string representation, optionally without comments."""
        if ignore_comments and self.instruction.has_comment:
            # Return the instruction without any comment
            if isinstance(self.instruction, Knitout_Comment_Line):
                return ""  # Comment-only lines become empty
            else:
                # For other instructions, return just the instruction part without comment
                return str(self.instruction).split(';')[0].rstrip()
        else:
            return str(self)

    def __str__(self) -> str:
        return str(self.instruction).rstrip('\n\r')

    def __repr__(self) -> str:
        return f"{self.line_number}: {self.instruction}"

    @property
    def operation(self) -> Knitout_Instruction_Type | None:
        """
        Returns:
            The operation type for knitout instructions or None for headers and comments.
        """
        if isinstance(self.instruction, Knitout_Instruction):
            return self.instruction.instruction_type

    @property
    def comment(self) -> str | None:
        """
        Returns:
            The comment attached to the parsed line or None if it has no comment.
        """
        return self.instruction.comment

    @property
    def is_version_line(self) -> bool:
        """
        Returns:
            True if this instruction is a version line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Version_Line)

    @property
    def is_header(self) -> bool:
        """
        Returns:
            True if this instruction is a header line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Header_Line)

    @property
    def only_comment(self) -> bool:
        """
        Returns:
            True if instruction is only a comment line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Comment_Line)

    @property
    def tokens(self) -> list[str]:
        """
        Returns:
            List of normalized token strings for each type of operation.
        """
        tokens = []
        if isinstance(self.instruction, Knitout_Version_Line):
            tokens = ['knitout-version', str(self.instruction.version)]
        elif isinstance(self.instruction, Knitout_Header_Line):
            tokens = [str(self.instruction.header_type), str(self.instruction.header_value)]
        elif isinstance(self.instruction, Knitout_Instruction):
            tokens = [self.instruction.instruction_type]
            if isinstance(self.instruction, Rack_Instruction):
                tokens.append(str(self.instruction.rack_value))
            elif isinstance(self.instruction, Yarn_Carrier_Instruction):
                tokens.extend([self.instruction.carrier_id])
            elif isinstance(self.instruction, Needle_Instruction):
                if self.instruction.has_direction:
                    tokens.append(str(self.instruction.direction))
                tokens.append(str(self.instruction.needle))
                if self.instruction.has_second_needle:
                    tokens.append(str(self.instruction.needle_2))
                if self.instruction.has_carrier_set:
                    tokens.append(str(self.instruction.carrier_set))
        # if self.comment is not None:
        #     tokens.extend(self.comment)
        return [str(t) for t in tokens]


@dataclass
class Knitout_Difference_Block:
    """Class for tracking a block of differences between 2 knitout files."""
    difference_operation: DiffType
    change_type: str
    lines1: list[Knitout_Diff_Line]
    lines2: list[Knitout_Diff_Line]
    lines_1_start: int
    lines_2_start: int
    lines_1_end: int
    lines_2_end: int

    def is_transfer_only_block(self) -> bool:
        """
        Check if a block contains only transfer operations (regardless of change type).

        Returns:
            True if the block only contains transfer operations
        """
        if len(self.lines1) == 0 and len(self.lines2) == 0:
            return False  # must have operations
        non_xfers_1 = any(isinstance(line, Xfer_Instruction) for line in self.lines1)
        non_xfers_2 = any(isinstance(line, Xfer_Instruction) for line in self.lines2)
        return not non_xfers_1 and not non_xfers_2

    def is_only_reorderd_transfers(self) -> bool:
        """
            Check if an operation diff block represents only transfer operation reordering.

            Transfer operations can typically be executed in any order without affecting
            the final knitted result, so reordering them should be considered functionally
            equivalent.

            Returns:
                True if the block only contains transfer reordering, False otherwise.
            """
        # Only check 'replace' type changes (where lines were replaced with different lines)
        # Only check if both lines contain the same number of xfers
        # Only check if everything is a transfer
        if (self.change_type != 'replace' or len(self.lines1) != len(self.lines2)
                or not self.is_transfer_only_block()):
            return False
        xfers_1 = set((line.instruction.needle, line.instruction.needle_2) for line in self.lines1 if isinstance(line.instruction, Xfer_Instruction))
        xfers_2 = set((line.instruction.needle_2, line.instruction.needle) for line in self.lines2 if isinstance(line.instruction, Xfer_Instruction))
        return xfers_1 == xfers_2

    def get_xfers(self) -> set[tuple[Needle, Needle]]:
        """
        Returns:
            Set of transferred needle pairs for all transfer operations in this block.
        """
        xfers = set((line.instruction.needle, line.instruction.needle_2) for line in self.lines1 if isinstance(line.instruction, Xfer_Instruction))
        xfers.update((line.instruction.needle, line.instruction.needle_2) for line in self.lines2 if isinstance(line.instruction, Xfer_Instruction))
        return xfers

    def matching_xfer_blocks(self, other_block) -> bool:
        """
        Args:
            other_block: The other Knitout_Difference_Block to compare for insertion and deletion of xfers.

        Returns:
            True if both blocks are corresponding insert-delete pairs of the same xfers.
        """
        assert isinstance(other_block, Knitout_Difference_Block)
        if self.change_type == 'insert':
            if other_block.change_type != 'delete':
                return False
        elif self.change_type == 'delete':
            if other_block.change_type != 'insert':
                return False
        xfers_1 = self.get_xfers()
        xfers_2 = other_block.get_xfers()
        return xfers_1 == xfers_2  # both blocks have the same xfers, thus they are replaced by the reordering.


class Knitout_Diff_Result:
    """
    Represents the result of a knitout file comparison with comprehensive equivalence analysis.
    """

    def __init__(self, header_diffs: list[dict], operation_diffs: list[Knitout_Difference_Block], unified_diff: str):
        """
        Initialize the diff result and calculate all equivalence assessments.

        Args:
            header_diffs: List of header differences
            operation_diffs: List of operation differences
            unified_diff: Traditional unified diff output
        """
        # Store basic diff results
        self.header_diffs: list[dict] = header_diffs
        self.operation_diffs: list[Knitout_Difference_Block] = operation_diffs
        self.significant_diffs: list[Knitout_Difference_Block] = []
        self.transfer_order_diffs: list[Knitout_Difference_Block] = []
        self._analyze_transfer_differences()
        self.unified_diff = unified_diff

    @staticmethod
    def _is_transfer_only_block(operation_diff_block: dict) -> bool:
        """
        Check if a block contains only transfer operations (regardless of change type).

        Args:
            operation_diff_block: A single operation diff block

        Returns:
            True if the block only contains transfer operations
        """
        # Check lines1 (deleted/original lines)
        lines1 = operation_diff_block.get('lines1', [])
        for line in lines1:
            if not isinstance(line.instruction, Xfer_Instruction):
                return False

        # Check lines2 (inserted/new lines)
        lines2 = operation_diff_block.get('lines2', [])
        for line in lines2:
            if not isinstance(line.instruction, Xfer_Instruction):
                return False

        # If we get here, all operations in both sides are transfers
        return len(lines1) > 0 or len(lines2) > 0  # Must have at least some operations

    @staticmethod
    def _extract_transfers_from_block(operation_diff_block: dict) -> set[tuple[Needle, Needle]]:
        """
        Extract all transfer operations from a diff block as a set of tuples.

        Args:
            operation_diff_block: A single operation diff block

        Returns:
            Set of (from_needle, to_needle) tuples representing all transfers in the block
        """
        transfers = set()

        # Extract from lines1 (deleted/original)
        lines1 = operation_diff_block.get('lines1', [])
        for line in lines1:
            if isinstance(line.instruction, Xfer_Instruction):
                from_needle = str(line.instruction.needle)
                to_needle = str(line.instruction.needle_2)
                transfers.add((from_needle, to_needle))

        # Extract from lines2 (inserted/new)
        lines2 = operation_diff_block.get('lines2', [])
        for line in lines2:
            if isinstance(line.instruction, Xfer_Instruction):
                from_needle = line.instruction.needle
                to_needle = line.instruction.needle_2
                transfers.add((from_needle, to_needle))

        return transfers

    def _analyze_transfer_differences(self) -> None:
        """
        Analyze operation differences to separate significant changes from transfer reordering,
        including cross-block transfer reordering (insert + delete blocks).
        """
        # Track which blocks contain only transfers
        self.transfer_order_diffs = []
        self.significant_diffs = []
        current_xfer_change_blocks = []
        current_insertions = set()
        current_deletions = set()

        def _insertions_deletions_cancel() -> bool:
            return current_insertions == current_deletions

        # First pass: categorize individual blocks and collect transfers
        for block in self.operation_diffs:
            if block.is_only_reorderd_transfers():
                self.transfer_order_diffs.append(block)
            elif block.is_transfer_only_block():  # This block contains only transfers to insert or delete which may match another sections reordering.
                if block.change_type == 'insert':
                    current_xfer_change_blocks.append(block)
                    current_insertions.update(block.get_xfers())
                elif block.change_type == 'delete':
                    current_xfer_change_blocks.append(block)
                    current_deletions.update(block.get_xfers())
                if _insertions_deletions_cancel():
                    self.transfer_order_diffs.extend(current_xfer_change_blocks)
                    current_xfer_change_blocks = []
                    current_insertions = set()
                    current_deletions = set()
            else:  # This block has significant (non-transfer) changes
                self.significant_diffs.append(block)
                # other types of changes cancel out the current set of insertion-deletion pairs
                self.significant_diffs.extend(current_xfer_change_blocks)
                current_xfer_change_blocks = []
                current_insertions = set()
                current_deletions = set()

        self.significant_diffs.extend(current_xfer_change_blocks)  # remaining xfer changes have not been resolved.

    @property
    def are_equivalent(self) -> bool:
        """
        Returns:
            True if the files are identical except for whitespace and comments.
        """
        return not self.has_header_differences and len(self.operation_diffs) == 0

    @property
    def are_functionally_equivalent(self) -> bool:
        """
        Returns:
            True if the only differences are significant.
        """
        return not self.has_significant_differences

    @property
    def has_header_differences(self) -> bool:
        """
        Returns:
            True if there are header differences.
        """
        return len(self.header_diffs) > 0

    @staticmethod
    def is_transfer_reordering_only(operation_diff_block: dict) -> bool:
        """
        Check if an operation diff block represents only transfer operation reordering.

        Transfer operations can typically be executed in any order without affecting
        the final knitted result, so reordering them should be considered functionally
        equivalent.

        Args:
            operation_diff_block: A single operation diff block from operation_diffs

        Returns:
            True if the block only contains transfer reordering, False otherwise

        Example:
            for diff_block in result.operation_diffs:
                if differ.is_transfer_reordering_only(diff_block):
                    print("This block is just transfer reordering - functionally equivalent")
        """
        # Only check 'replace' type changes (where lines were replaced with different lines)
        if operation_diff_block.get('change_type') != 'replace':
            return False

        lines1 = operation_diff_block.get('lines1', [])
        lines2 = operation_diff_block.get('lines2', [])

        # Must have the same number of operations
        if len(lines1) != len(lines2):
            return False

        # All operations in both sets must be transfer operations
        transfers1 = []
        transfers2 = []

        for line in lines1:
            if not isinstance(line.instruction, Xfer_Instruction):
                return False
            transfers1.append(line.instruction)

        for line in lines2:
            if not isinstance(line.instruction, Xfer_Instruction):
                return False
            transfers2.append(line.instruction)

        # Create sets of transfer operations for comparison
        # Each transfer is represented as a tuple of (from_needle, to_needle, carrier_set)
        transfer_set1 = set()
        transfer_set2 = set()

        for xfer in transfers1:
            # Create a hashable representation of the transfer
            from_needle = str(xfer.needle)
            to_needle = str(xfer.needle_2)
            transfer_set1.add((from_needle, to_needle))

        for xfer in transfers2:
            # Create a hashable representation of the transfer
            from_needle = str(xfer.needle)
            to_needle = str(xfer.needle_2)
            transfer_set2.add((from_needle, to_needle))

        # If the sets are identical, it's just reordering
        return transfer_set1 == transfer_set2

    @property
    def has_significant_differences(self) -> bool:
        """
        Returns:
            True if there are significant differences.
        """
        return len(self.significant_diffs) > 0

    @property
    def has_transfer_reordering_differences(self) -> bool:
        """
        Returns:
            True if there are transfer reordering blocks.
        """
        return len(self.transfer_order_diffs) > 0

    @property
    def summary(self) -> str:
        """Generate a human-readable summary of differences."""
        if self.are_equivalent:
            return "Files are equivalent."
        elif self.are_functionally_equivalent:
            return "Files are functionally equivalent."

        summary_parts = []

        if len(self.header_diffs) > 0:
            summary_parts.append(f"Header differences: {len(self.header_diffs)}")
            for diff in self.header_diffs:
                key = diff['key']
                if diff['value1'] is None:
                    summary_parts.append(f"  + Added header: {key}")
                elif diff['value2'] is None:
                    summary_parts.append(f"  - Removed header: {key}")
                else:
                    summary_parts.append(f"  ~ Modified header: {key}")
        if len(self.transfer_order_diffs) > 0:
            total_changes = sum(len(diff.lines1) + len(diff.lines2) for diff in self.transfer_order_diffs)
            summary_parts.append(f"Transfer Order Differences: {len(self.transfer_order_diffs)} blocks, {total_changes} lines")
        if len(self.significant_diffs) > 0:
            total_changes = sum(len(diff.lines1) + len(diff.lines2) for diff in self.significant_diffs)
            summary_parts.append(f"Operation differences: {len(self.significant_diffs)} blocks, {total_changes} lines")

            for i, diff in enumerate(self.significant_diffs):
                if diff.change_type == 'replace':
                    summary_parts.append(f"  Block {i + 1}: {len(diff.lines1)} lines replaced with {len(diff.lines2)} lines")
                elif diff.change_type == 'delete':
                    summary_parts.append(f"  Block {i + 1}: {len(diff.lines1)} lines deleted")
                elif diff.change_type == 'insert':
                    summary_parts.append(f"  Block {i + 1}: {len(diff.lines2)} lines inserted")

        return '\n'.join(summary_parts)

    def simple_report(self, file1_path: str, file2_path: str) -> None:
        """
        Print out a simple report of the difference results.
        Args:
            file1_path: The name of the first file.
            file2_path: The name of the second file.
        """
        if self.are_equivalent:
            print(f"✓✓ {file1_path} and {file2_path} are equivalent")
        else:
            if self.are_functionally_equivalent:
                print(f"✓ {file1_path} and {file2_path} are functionally equivalent:")
                if self.has_transfer_reordering_differences:
                    print("Transfer operation reordering detected")
                if self.has_header_differences:
                    print("Has Header Differences")
            else:
                print(f"✗ {file1_path} and {file2_path} have {len(self.significant_diffs)} significant differences")

    def verbose_report(self, file1_path: str, file2_path: str) -> None:
        """
        Printout a verbose report of the difference results.
        Args:
            file1_path: The name of the first file.
            file2_path: The name of the second file.
        """
        print(f"Comparing {file1_path} and {file2_path}")
        print("=" * 50)
        print(self.summary)
        print("\nDetailed diff:")
        print("-" * 30)
        print(self.unified_diff)


def parse_file(knitout_file: str) -> list[Knitout_Diff_Line]:
    """
    Parse a knitout file into structured KnitoutLine objects.

    Args:
        knitout_file: Path to the knitout file.

    Returns:
        list of KnitoutLine objects representing the parsed file.

    Raises:
        FileNotFoundError: If the file doesn't exist.
    """
    knitout_lines = parse_knitout(knitout_file, pattern_is_file=True)

    parsed_lines = []

    for line_num, knitout_line in enumerate(knitout_lines, 1):
        diff_line = Knitout_Diff_Line(knitout_line, line_num)
        parsed_lines.append(diff_line)

    return parsed_lines


def _extract_meaningful_lines(lines: list[Knitout_Diff_Line], ignore_version: bool = True, ignore_comments: bool = True) -> list[Knitout_Diff_Line]:
    """Extract lines that are meaningful for comparison."""
    meaningful = []

    for line in lines:
        if line.is_header:  # Always include  headers
            meaningful.append(line)
        elif line.operation is not None:  # Include lines with operations
            meaningful.append(line)
        elif not ignore_version and line.is_version_line:  # include version lines if not ignoring
            meaningful.append(line)
        elif not ignore_comments and line.only_comment:  # include comments if not ignoring
            meaningful.append(line)

    return meaningful


class KnitoutDiffer:
    """
    Main class for comparing knitout files and generating semantic diffs.
    """

    def __init__(self, ignore_comments: bool = True, ignore_whitespace: bool = True, ignore_version: bool = True):
        """
        Initialize the KnitoutDiffer.

        Args:
            ignore_comments: If True, ignore comment differences
            ignore_whitespace: If True, ignore whitespace-only differences
        """
        self.ignore_comments: bool = ignore_comments
        self.ignore_whitespace: bool = ignore_whitespace
        self.ignore_version: bool = ignore_version

    def diff_files(self, file1_path: str, file2_path: str) -> Knitout_Diff_Result:
        """
        Compare two knitout files and return a comprehensive diff result.

        Args:
            file1_path: Path to the first knitout file
            file2_path: Path to the second knitout file

        Returns:
            DiffResult object containing comparison results
        """
        # Parse both files
        lines1 = parse_file(file1_path)
        lines2 = parse_file(file2_path)

        # Extract meaningful lines (ignore empty lines and comments if configured)
        meaningful1 = _extract_meaningful_lines(lines1, self.ignore_version, self.ignore_comments)
        meaningful2 = _extract_meaningful_lines(lines2, self.ignore_version, self.ignore_comments)

        # Separate headers and operations
        headers1, operations1 = self._separate_headers_operations(meaningful1)
        headers2, operations2 = self._separate_headers_operations(meaningful2)

        # Compare headers
        header_diffs = self._compare_headers(headers1, headers2)

        # Compare operations
        operation_diffs = self._compare_operations(operations1, operations2)

        # Generate unified diff
        unified_diff = self._generate_unified_diff(lines1, lines2, file1_path, file2_path)

        return Knitout_Diff_Result(header_diffs, operation_diffs, unified_diff)

    @staticmethod
    def _separate_headers_operations(lines: list[Knitout_Diff_Line]) -> tuple[list[Knitout_Diff_Line], list[Knitout_Diff_Line]]:
        """Separate header lines from operation lines."""
        headers = []
        operations = []

        for line in lines:
            if line.is_version_line or line.is_header:
                headers.append(line)
            else:
                operations.append(line)

        return headers, operations

    def _compare_headers(self, headers1: list[Knitout_Diff_Line], headers2: list[Knitout_Diff_Line]) -> list[dict]:
        """Compare header sections of two files."""
        diffs = []

        # Convert headers to dictionaries for easier comparison
        headers1_dict = self._headers_to_dict(headers1)
        headers2_dict = self._headers_to_dict(headers2)

        # Find differences
        all_keys = set(headers1_dict.keys()) | set(headers2_dict.keys())

        for key in all_keys:
            if key in headers1_dict:
                head1 = headers1_dict[key]
                assert isinstance(head1.instruction, Knitout_Header_Line)
                val1 = head1.instruction.header_value
            else:
                head1 = None
                val1 = None
            if key in headers2_dict:
                head2 = headers2_dict[key]
                assert isinstance(head2.instruction, Knitout_Header_Line)
                val2 = head2.instruction.header_value
            else:
                head2 = None
                val2 = None
            if val1 != val2:
                diffs.append({
                    'type': DiffType.HEADER,
                    'key': key,
                    'value1': val1,
                    'value2': val2,
                    'line1': head1.line_number if head1 is not None else None,
                    'line2': head2.line_number if head2 is not None else None
                })

        return diffs

    @staticmethod
    def _headers_to_dict(headers: list[Knitout_Diff_Line]) -> dict[Knitout_Header_Line_Type, Knitout_Diff_Line]:
        """Convert header lines to a dictionary."""
        return {h.instruction.header_type: h for h in headers if isinstance(h.instruction, Knitout_Header_Line)}

    def _compare_operations(self, ops1: list[Knitout_Diff_Line], ops2: list[Knitout_Diff_Line]) -> list[Knitout_Difference_Block]:
        """Compare operation sequences of two files."""
        diffs = []

        # Normalize operations for comparison
        norm_ops1 = [self._normalize_operation(op) for op in ops1]
        norm_ops2 = [self._normalize_operation(op) for op in ops2]

        # Use difflib to find differences
        matcher = difflib.SequenceMatcher(None, norm_ops1, norm_ops2)

        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'equal':
                continue
            diffs.append(Knitout_Difference_Block(DiffType.OPERATION, tag, ops1[i1:i2], ops2[j1:j2], i1, j1, i2, j2))

        return diffs

    @staticmethod
    def _normalize_operation(line: Knitout_Diff_Line) -> str:
        """Normalize an operation for comparison."""
        if len(line.tokens) == 0:
            return ""
        # Join tokens with single spaces
        return " ".join(line.tokens)

    def _generate_unified_diff(self, lines1: list[Knitout_Diff_Line], lines2: list[Knitout_Diff_Line],
                               file1_path: str, file2_path: str) -> str:
        """Generate a unified diff string."""
        lines1 = _extract_meaningful_lines(lines1, self.ignore_version, self.ignore_comments)
        lines2 = _extract_meaningful_lines(lines2, self.ignore_version, self.ignore_comments)
        text1 = [line.get_normalized_string(ignore_comments=self.ignore_comments) for line in lines1]
        text2 = [line.get_normalized_string(ignore_comments=self.ignore_comments) for line in lines2]

        diff = difflib.unified_diff(
            text1, text2,
            fromfile=file1_path,
            tofile=file2_path,
            lineterm=''
        )

        return '\n'.join(diff)


def diff_knitout_files(file1_path: str, file2_path: str,
                       ignore_comments: bool = True,
                       ignore_whitespace: bool = True,
                       ignore_version: bool = True,
                       verbose: bool = False,
                       simple_report: bool = False) -> Knitout_Diff_Result:
    """
    Convenience function to diff two knitout files.

    Args:
        file1_path: Path to the first knitout file.
        file2_path: Path to the second knitout file.
        ignore_comments: If True, ignore comment differences (default: True).
        ignore_whitespace: If True, ignore whitespace-only differences (default: True).
        ignore_version: If True, ignore the version line differences (default: True).
        verbose: If True, print detailed output (default: False).
        simple_report: If True, print a simple report if the files are functionally equivalent.

    Returns:
        DiffResult object containing comparison results.
    """
    differ = KnitoutDiffer(ignore_comments=ignore_comments, ignore_whitespace=ignore_whitespace, ignore_version=ignore_version)
    diff_result = differ.diff_files(file1_path, file2_path)
    if simple_report:
        diff_result.simple_report(file1_path, file2_path)
    if verbose:
        diff_result.verbose_report(file1_path, file2_path)

    return diff_result


def analyze_knitout_structure(filepath: str) -> dict:
    """
    Analyze the structure of a knitout file for debugging and understanding.

    Args:
        filepath: Path to the knitout file

    Returns:
        Dictionary containing structural analysis

    Example:
        analysis = analyze_knitout_structure('pattern.k')
        print(f"File has {analysis['total_operations']} operations")
        print(f"Uses {len(analysis['carriers'])} carriers: {analysis['carriers']}")
        print(f"Needle range: {analysis['needle_range']}")
    """
    lines = parse_file(filepath)

    analysis = {
        'total_lines': len(lines),
        'comment_lines': 0,
        'header_lines': 0,
        'operation_lines': 0,
        'headers': {},
        'operations': {},
        'carriers': set(),
        'needles': set(),
        'needle_range': None,
        'opcodes_used': set()
    }
    min_needle = 1000
    max_needle = -1

    for line in lines:
        if isinstance(line.instruction, Knitout_Header_Line):
            analysis['header_lines'] += 1
            analysis['headers'][str(line.instruction.header_type)] = str(line.instruction.header_value)
        elif isinstance(line.instruction, Knitout_Instruction):
            analysis['operation_lines'] += 1
            opcode = line.instruction.instruction_type
            analysis['opcodes_used'].add(opcode)

            if opcode not in analysis['operations']:
                analysis['operations'][opcode] = 0
            analysis['operations'][opcode] += 1
            # Extract carriers and needles
            if isinstance(line.instruction, Yarn_Carrier_Instruction):
                analysis['carriers'].add(str(line.instruction.carrier_id))
            elif isinstance(line.instruction, Needle_Instruction) and line.instruction.has_carrier_set:
                analysis['carriers'].update(str(cid) for cid in line.instruction.carrier_set.carrier_ids)
            if isinstance(line.instruction, Needle_Instruction):
                analysis['needles'].add(str(line.instruction.needle))
                min_needle = min(min_needle, line.instruction.needle)
                max_needle = max(max_needle, line.instruction.needle)
                if line.instruction.has_second_needle:
                    analysis['needles'].add(str(line.instruction.needle_2))
                    min_needle = min(min_needle, line.instruction.needle_2)
                    max_needle = max(max_needle, line.instruction.needle_2)
        else:
            analysis['comment_lines'] += 1

    # Calculate needle range
    if analysis['needles']:
        analysis['needle_range'] = min_needle, max_needle

    # Convert sets to lists for JSON serialization
    analysis['carriers'] = list(analysis['carriers'])
    analysis['needles'] = list(analysis['needles'])
    analysis['opcodes_used'] = list(analysis['opcodes_used'])

    return analysis


if __name__ == "__main__":
    import sys

    if len(sys.argv) != 3:
        print("Usage: python knitout_diff.py <file1.k> <file2.k>")
        sys.exit(1)

    file1, file2 = sys.argv[1], sys.argv[2]

    try:
        result = diff_knitout_files(file1, file2, verbose=True)
        result.simple_report(file1, file2)
        if result.are_equivalent:
            sys.exit(0)
        else:
            sys.exit(1)

    except Exception as e:
        print(f"Error: {e}")
        sys.exit(2)
