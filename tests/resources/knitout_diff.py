"""
Knitout File Diff Tool: Generated by CLaude AI

A Python module for comparing knitout (.k) files with semantic understanding
of the knitout format. This tool provides Git-style diffs while ignoring
insignificant differences like comments and whitespace variations.

Based on the knitout specification: https://textiles-lab.github.io/knitout/knitout.html

Author: Assistant
Date: 2025
"""

import difflib
from dataclasses import dataclass
from enum import Enum

from knitout_interpreter.knitout_language.Knitout_Parser import parse_knitout
from knitout_interpreter.knitout_operations.Header_Line import Knitout_Header_Line, Knitout_Header_Line_Type
from knitout_interpreter.knitout_operations.Knitout_Line import Knitout_Line, Knitout_Version_Line, Knitout_Comment_Line
from knitout_interpreter.knitout_operations.Rack_Instruction import Rack_Instruction
from knitout_interpreter.knitout_operations.carrier_instructions import Yarn_Carrier_Instruction
from knitout_interpreter.knitout_operations.knitout_instruction import Knitout_Instruction, Knitout_Instruction_Type
from knitout_interpreter.knitout_operations.needle_instructions import Needle_Instruction, Xfer_Instruction
from virtual_knitting_machine.machine_components.carriage_system.Carriage_Pass_Direction import Carriage_Pass_Direction


class DiffType(Enum):
    """Types of differences that can be found between knitout files."""
    HEADER = "header"
    OPERATION = "operation"
    STRUCTURE = "structure"

    def __str__(self) -> str:
        return self.name

    def __repr__(self) -> str:
        return self.name

    def __hash__(self) -> int:
        return hash(self.name)


@dataclass
class Knitout_Diff_Line:
    """
    Represents a parsed line from a knitout file.

    Attributes:
        instruction: The parsed Knitout Line.
        line_number: Original line number in the file.
    """
    instruction: Knitout_Line
    line_number: int

    def get_normalized_string(self, ignore_comments: bool = False) -> str:
        """Get a normalized string representation, optionally without comments."""
        if ignore_comments and self.instruction.has_comment:
            # Return the instruction without any comment
            if isinstance(self.instruction, Knitout_Comment_Line):
                return ""  # Comment-only lines become empty
            else:
                # For other instructions, return just the instruction part without comment
                return str(self.instruction).split(';')[0].rstrip()
        else:
            return str(self)

    def __str__(self) -> str:
        return str(self.instruction).rstrip('\n\r')

    def __repr__(self) -> str:
        return f"{self.line_number}: {self.instruction}"

    @property
    def operation(self) -> Knitout_Instruction_Type | None:
        """
        Returns:
            The operation type for knitout instructions or None for headers and comments.
        """
        if isinstance(self.instruction, Knitout_Instruction):
            return self.instruction.instruction_type

    @property
    def comment(self) -> str | None:
        """
        Returns:
            The comment attached to the parsed line or None if it has no comment.
        """
        return self.instruction.comment

    @comment.setter
    def comment(self, comment: str | None) -> None:
        self.instruction.comment = comment

    @property
    def is_version_line(self) -> bool:
        """
        Returns:
            True if this instruction is a version line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Version_Line)

    @property
    def is_header(self) -> bool:
        """
        Returns:
            True if this instruction is a header line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Header_Line)

    @property
    def only_comment(self) -> bool:
        """
        Returns:
            True if instruction is only a comment line. False, otherwise.
        """
        return isinstance(self.instruction, Knitout_Comment_Line)

    @property
    def tokens(self) -> list[str]:
        """
        Returns:
            List of normalized token strings for each type of operation.
        """
        tokens = []
        if isinstance(self.instruction, Knitout_Version_Line):
            tokens = ['knitout-version', str(self.instruction.version)]
        elif isinstance(self.instruction, Knitout_Header_Line):
            tokens = [str(self.instruction.header_type), str(self.instruction.header_value)]
        elif isinstance(self.instruction, Knitout_Instruction):
            tokens = [self.instruction.instruction_type]
            if isinstance(self.instruction, Rack_Instruction):
                tokens.append(str(self.instruction.rack_value))
            elif isinstance(self.instruction, Yarn_Carrier_Instruction):
                tokens.extend([self.instruction.carrier_id])
            elif isinstance(self.instruction, Needle_Instruction):
                if self.instruction.has_direction:
                    tokens.append(str(self.instruction.direction))
                tokens.append(str(self.instruction.needle))
                if self.instruction.has_second_needle:
                    tokens.append(str(self.instruction.needle_2))
                if self.instruction.has_carrier_set:
                    tokens.append(str(self.instruction.carrier_set))
        # if self.comment is not None:
        #     tokens.extend(self.comment)
        return [str(t) for t in tokens]


class Knitout_Difference_Block_Tag(Enum):
    """Enumeration of different Knitout Difference Block Tags."""
    equal = 'equal'
    insert = 'insert'
    delete = 'delete'
    replace = 'replace'


class Knitout_Difference_Block:
    """Class for tracking a block of differences between 2 knitout files."""

    def __init__(self, tag: Knitout_Difference_Block_Tag | str, lines1: list[Knitout_Diff_Line], lines2: list[Knitout_Diff_Line],
                 start_1: int, end_1: int, start_2: int, end_2: int):
        self.end_2: int = end_2
        self.start_2: int = start_2
        self.end_1: int = end_1
        self.start_1: int = start_1
        if isinstance(tag, str):
            tag = Knitout_Difference_Block_Tag(tag)
        self.change_type: Knitout_Difference_Block_Tag = tag
        self.lines1: list[Knitout_Diff_Line] = lines1
        self.lines2: list[Knitout_Diff_Line] = lines2

    def is_equivalent_all_needle(self) -> bool:
        """
        Returns: True if this difference block is a replacement that only represents a difference of all-needle operations.

        """
        if self.change_type is not Knitout_Difference_Block_Tag.replace:
            return False
        pairlines_1 = zip(self.lines1[0:2:-1], self.lines1[1:2:])
        pairlines_2 = zip(self.lines2[0:2:-1], self.lines2[1:2:])

        def _all_needle_pairs(a1: Knitout_Diff_Line, a2: Knitout_Diff_Line, b1: Knitout_Diff_Line, b2: Knitout_Diff_Line) -> bool:
            """
            Args:
                a1: The first diff line from the first instruction set.
                a2: The second diff line form the first instruction set.
                b1: The first diff line from the second instruction set.
                b2: The second diff line from the second instruction set.

            Returns: True if you can swap the two instruction pairs to form the same set of all needle operations

            """
            if any(not isinstance(l.instruction, Needle_Instruction) or l.instruction.has_second_needle for l in [a1, a2, b1, b2]):
                return False  # incompatible instruction types for all needle swap
            elif a1.operation != b2.operation or a2.operation != b1.operation:
                return False  # Unswappable pairs of operation
            a1 = a1.instruction
            a2 = a2.instruction
            b1 = b1.instruction
            b2 = b2.instruction
            assert isinstance(a1, Needle_Instruction)
            assert isinstance(a2, Needle_Instruction)
            assert isinstance(b1, Needle_Instruction)
            assert isinstance(b2, Needle_Instruction)
            if any(l.direction != a1.direction for l in [a2, b1, b2]):  # Directions must match for all elements in the pair
                return False
            elif a1.needle != b2.needle or a2.needle != b1.needle:
                return False
            return True

        for pair1, pair2 in zip(pairlines_1, pairlines_2):
            if not _all_needle_pairs(pair1[0], pair1[1], pair2[0], pair2[1]):
                return False
        return True

    def __str__(self) -> str:
        if self.change_type is Knitout_Difference_Block_Tag.insert or self.change_type is Knitout_Difference_Block_Tag.delete:
            return f"{self.change_type} Lines {self.start_1}:{self.end_1} at {self.start_2}:{self.end_2}"
        else:
            return f"{self.change_type} Lines {self.start_1}:{self.end_1} with {self.start_2}:{self.end_2}"

    def __repr__(self) -> str:
        return str(self)

    def report(self) -> list[str]:
        """
        Returns: A localized list of report strings of the difference block.
        The difference block references the line numbers location in each file
        and then reports a line by line comparison of the change.
        Each block ends at a set of "------"

        """
        report = [f"@@ {self.start_1}:{self.end_1} and {self.start_2}:{self.end_2}@@"]
        if self.change_type is Knitout_Difference_Block_Tag.insert:
            left_mod = "+"
            right_mod = "-"
            mid_mod = "---"
        elif self.change_type is Knitout_Difference_Block_Tag.delete:
            left_mod = "-"
            right_mod = "+"
            mid_mod = "---"
        elif self.change_type is Knitout_Difference_Block_Tag.replace:
            left_mod = "*"
            right_mod = "*"
            mid_mod = "<->"
        else:
            left_mod = ""
            right_mod = ""
            mid_mod = "==="
        for line1, line2 in zip(self.lines1, self.lines2):
            line1_str = str(line1).strip()
            line2_str = str(line2).strip()
            report.append(f"{left_mod} {line1_str} {mid_mod} {line2_str} {right_mod}")
        if len(self.lines1) > len(self.lines2):
            for line1 in self.lines1[len(self.lines2):]:
                line1_str = str(line1).strip()
                report.append(f"{left_mod} {line1_str} {mid_mod} NA {right_mod}")
        elif len(self.lines1) < len(self.lines2):
            for line2 in self.lines2[len(self.lines1):]:
                line2_str = str(line2).strip()
                report.append(f"{left_mod} NA {mid_mod} {line2_str} {right_mod}")
        report.append("--------------------------------------------------------")
        return report

    @property
    def can_be_rearranged(self) -> bool:
        """
        Given that the block only contains one carriage pass of instructions on either side,
            this implies that the block could be an insignificant difference.
            If the block is all xfers, this is in significant because the xfers will be coordinated by the machine.
            If the block is knitting operations in an all-needle-knit pattern, then it is insignificant.
        Returns:
            True if the lines (ignoring comments) could be rearranged to the same result.
        """
        if (self.change_type is Knitout_Difference_Block_Tag.replace  # must be set as replacement
                and len(self.lines1) != len(self.lines2) and  # Must be the same size
                any(not isinstance(l.instruction, Needle_Instruction) for l in self.lines1) and
                any(not isinstance(l.instruction, Needle_Instruction) for l in self.lines2)):
            return False  # Non-Needle instructions cannot be rearranged to be equivalent.
        normalized_lines_1 = set(l.get_normalized_string(ignore_comments=True) for l in self.lines1)
        normalized_lines_2 = set(l.get_normalized_string(ignore_comments=True) for l in self.lines2)
        symmetric_difference = normalized_lines_1.symmetric_difference(normalized_lines_2)
        return len(symmetric_difference) == 0

    @property
    def is_significant(self) -> bool:
        """
        Returns:
            True if this difference represents a knitting significant change.
            False for equal blocks, comment only differences, and re-arrangeable blocks of transfers.
        """
        if self.change_type is Knitout_Difference_Block_Tag.equal:
            return False  # Equal diffs means there is no difference, let alone a significant difference.
        elif self.can_be_rearranged:  # could be xfer or all-needle rearrangement
            if self.is_transfer_only_block():
                return False  # This is a block of re_arrangeable transfers.
            elif self.is_equivalent_all_needle():
                return False
        return True

    def is_transfer_only_block(self) -> bool:
        """
        Check if a block contains only transfer operations (regardless of change type).

        Returns:
            True if the block only contains transfer operations
        """
        if len(self.lines1) == 0 and len(self.lines2) == 0:
            return False  # must have operations
        non_xfers_1 = any(isinstance(line, Xfer_Instruction) for line in self.lines1)
        non_xfers_2 = any(isinstance(line, Xfer_Instruction) for line in self.lines2)
        return not non_xfers_1 and not non_xfers_2


class Knitout_Diff_Result:
    """
    Represents the result of a knitout file comparison with comprehensive equivalence analysis.
    """

    def __init__(self, filepath_1: str, filepath_2: str, header_diffs: list[dict], operation_diffs: list[Knitout_Difference_Block]):
        """
        Initialize the diff result and calculate all equivalence assessments.

        Args:
            filepath_1: The name of the first file.
            filepath_2: The name of the second file.
            header_diffs: List of header differences
            operation_diffs: List of operation differences
        """
        # Store basic diff results
        self.filepath_2: str = filepath_2
        self.filepath_1: str = filepath_1
        self.header_diffs: list[dict] = header_diffs
        self.operation_diffs: list[Knitout_Difference_Block] = operation_diffs
        self.significant_diffs: list[Knitout_Difference_Block] = []
        self.transfer_order_diffs: list[Knitout_Difference_Block] = []
        self.all_needle_order_diffs: list[Knitout_Difference_Block] = []
        self._analyze_transfer_differences()

    def report_significant_differences(self) -> str:
        """
        Returns: A report string of all the significant differences in the two files in the order that they were encountered.
        """
        report = f"{len(self.significant_diffs)} Significant Differences:\n"
        for diff in self.significant_diffs:
            report += f"\t{diff}\n"
        return report

    def _analyze_transfer_differences(self) -> None:
        """
        Analyze operation differences to separate significant changes from transfer reordering,
        including cross-block transfer reordering (insert + delete blocks).
        """
        for block in self.operation_diffs:
            if block.is_significant:
                self.significant_diffs.append(block)
            elif block.is_transfer_only_block() and block.can_be_rearranged:
                self.transfer_order_diffs.append(block)
            elif block.is_equivalent_all_needle():
                self.all_needle_order_diffs.append(block)

    @property
    def are_equivalent(self) -> bool:
        """
        Returns:
            True if the files are identical except for whitespace and comments.
        """
        return not self.has_header_differences and len(self.operation_diffs) == 0

    @property
    def are_functionally_equivalent(self) -> bool:
        """
        Returns:
            True if the only differences are significant.
        """
        return not self.has_significant_differences

    @property
    def has_header_differences(self) -> bool:
        """
        Returns:
            True if there are header differences.
        """
        return len(self.header_diffs) > 0

    @property
    def has_significant_differences(self) -> bool:
        """
        Returns:
            True if there are significant differences.
        """
        return len(self.significant_diffs) > 0

    @property
    def has_transfer_reordering_differences(self) -> bool:
        """
        Returns:
            True if there are transfer reordering blocks.
        """
        return len(self.transfer_order_diffs) > 0

    @property
    def has_all_needle_reordering_differences(self) -> bool:
        """
        Returns: True if there are all-needle reordering blocks.

        """
        return len(self.all_needle_order_diffs) > 0

    @property
    def summary(self) -> str:
        """Generate a human-readable summary of differences."""
        if self.are_equivalent:
            return "Files are equivalent."
        elif self.are_functionally_equivalent:
            return "Files are functionally equivalent."

        summary_parts: list[str] = []

        if self.has_header_differences:
            summary_parts.extend(summary_parts)
        if self.has_transfer_reordering_differences:
            total_changes = sum(len(diff.lines1) + len(diff.lines2) for diff in self.transfer_order_diffs)
            summary_parts.append(f"Transfer Order Differences: {len(self.transfer_order_diffs)} blocks, {total_changes} lines")
        if self.all_needle_order_diffs:
            total_changes = sum(len(diff.lines1) + len(diff.lines2) for diff in self.all_needle_order_diffs)
            summary_parts.append(f"All-Needle Order Differences: {len(self.all_needle_order_diffs)} blocks, {total_changes} lines")
        if len(self.significant_diffs) > 0:
            total_changes = sum(len(diff.lines1) + len(diff.lines2) for diff in self.significant_diffs)
            summary_parts.append(f"Operation differences: {len(self.significant_diffs)} blocks, {total_changes} lines")
            for diff in self.significant_diffs:
                summary_parts.extend(diff.report())
        return '\n'.join(summary_parts)

    def header_difference_summary(self) -> list[str]:
        """
        Returns:
            List of string-report differences between the headers.
        """
        if not self.has_header_differences:
            return ["No header differences."]
        summary_parts = [f"Header differences: {len(self.header_diffs)}"]
        for diff in self.header_diffs:
            key = diff['key']
            if diff['value1'] is None:
                summary_parts.append(f"  + Added header: {key}")
            elif diff['value2'] is None:
                summary_parts.append(f"  - Removed header: {key}")
            else:
                summary_parts.append(f"  ~ Modified header: {key}")
        return summary_parts

    def simple_report(self) -> None:
        """
        Print out a simple report of the difference results.
        """
        if self.are_equivalent:
            print(f"✓✓ {self.filepath_1} and {self.filepath_2} are equivalent")
        else:
            if self.are_functionally_equivalent:
                print(f"✓ {self.filepath_1} and {self.filepath_2} are functionally equivalent:")
                if self.has_transfer_reordering_differences:
                    print("Transfer operation reordering detected")
                if self.has_header_differences:
                    print("Has Header Differences")
            else:
                print(f"✗ {self.filepath_1} and {self.filepath_2} have {len(self.significant_diffs)} significant differences")

    def verbose_report(self) -> None:
        """
        Printout a verbose report of the difference results.
        """
        print(f"Comparing {self.filepath_1} and {self.filepath_2}")
        print("=" * 50)
        print(self.summary)


def parse_file(knitout_file: str) -> list[Knitout_Diff_Line]:
    """
    Parse a knitout file into structured KnitoutLine objects.

    Args:
        knitout_file: Path to the knitout file.

    Returns:
        list of KnitoutLine objects representing the parsed file.

    Raises:
        FileNotFoundError: If the file doesn't exist.
    """
    knitout_lines = parse_knitout(knitout_file, pattern_is_file=True)

    parsed_lines = []

    for line_num, knitout_line in enumerate(knitout_lines, 1):
        diff_line = Knitout_Diff_Line(knitout_line, line_num)
        parsed_lines.append(diff_line)

    return parsed_lines


class KnitoutDiffer:
    """
    Main class for comparing knitout files and generating semantic diffs.
    """

    def __init__(self, file1_path: str, file2_path: str, ignore_comments: bool = True, ignore_whitespace: bool = True, ignore_version: bool = True, shift_file1: int = 0, shift_file2: int = 0) -> None:
        """
        Initialize the KnitoutDiffer.

        Args:
            file1_path: The file path of the first file.
            file2_path: The file path of the second file.
            ignore_comments: If True, ignore comment differences
            ignore_whitespace: If True, ignore whitespace-only differences
        """
        self.file1_path: str = file1_path
        self.file2_path: str = file2_path
        self.ignore_comments: bool = ignore_comments
        self.ignore_whitespace: bool = ignore_whitespace
        self.ignore_version: bool = ignore_version
        self._lines1 = self._clear_meaningless_content(parse_file(self.file1_path))
        if shift_file1 != 0:
            for line in self._lines1:
                if isinstance(line.instruction, Needle_Instruction):
                    line.instruction.needle += shift_file1
                    if line.instruction.has_second_needle:
                        line.instruction.needle_2 += shift_file1
        self._lines2 = self._clear_meaningless_content(parse_file(self.file2_path))
        if shift_file2 != 0:
            for line in self._lines2:
                if isinstance(line.instruction, Needle_Instruction):
                    line.instruction.needle += shift_file2
                    if line.instruction.has_second_needle:
                        line.instruction.needle_2 += shift_file2
        self._headers1: list[Knitout_Diff_Line] = []
        self._operations1: list[Knitout_Diff_Line] = []
        self._headers2: list[Knitout_Diff_Line] = []
        self._operations2: list[Knitout_Diff_Line] = []
        self._headers1, self._operations1 = self._separate_headers_operations(self._lines1)
        self._headers2, self._operations2 = self._separate_headers_operations(self._lines2)
        self.header_diffs: list[dict] = self._compare_headers()
        self._operations1_blocks: list[list[Knitout_Diff_Line]] = self._process_operations_to_operation_blocks(self._operations1)
        self._operations2_blocks: list[list[Knitout_Diff_Line]] = self._process_operations_to_operation_blocks(self._operations2)
        self.operation_diffs: list[Knitout_Difference_Block] = self._compare_operations()
        # Generate unified diff
        # self.unified_diff = self._generate_unified_diff(self.file1_path, self.file2_path)

    def _process_operations_to_operation_blocks(self, ops: list[Knitout_Diff_Line], block_types: set[Knitout_Instruction_Type] | None = None) -> list[list[Knitout_Diff_Line]]:
        blocks = self._block_operations(ops, block_types)
        reduced_rack_blocks = self._reduce_racks(blocks)
        merged_blocks = self._merge_blocks(reduced_rack_blocks)
        direction_blocks = self._block_operations_by_direction(merged_blocks)
        rack_reduced_blocks = self._clear_end_racks(direction_blocks)
        return rack_reduced_blocks

    @staticmethod
    def _block_operations(ops: list[Knitout_Diff_Line], block_types: set[Knitout_Instruction_Type] | None = None) -> list[list[Knitout_Diff_Line]]:
        if block_types is None:
            block_types = {Knitout_Instruction_Type.Xfer, Knitout_Instruction_Type.Rack}
        op_blocks = []
        current_op_block: list[Knitout_Diff_Line] = []
        current_block_type = None
        for op in ops:
            if op.operation in block_types:
                if op.operation is not current_block_type and len(current_op_block) != 0:  # reset op block
                    op_blocks.append(current_op_block)
                    current_op_block = []
                current_block_type = op.operation
            elif current_block_type is not None:  # reset xfer op block for incoming non_xfer
                op_blocks.append(current_op_block)
                current_op_block = []
                current_block_type = None
            current_op_block.append(op)
        if len(current_op_block) > 0:
            op_blocks.append(current_op_block)
        return op_blocks

    @staticmethod
    def _clear_end_racks(op_blocks: list[list[Knitout_Diff_Line]]) -> list[list[Knitout_Diff_Line]]:
        i = 0
        clean_blocks: list[list[Knitout_Diff_Line]] = []
        for op_block in reversed(op_blocks):
            if isinstance(op_block[-1].instruction, Needle_Instruction):
                break  # found some needle operations that depend on prior racks
            i -= 1
            if op_block[0].operation is not Knitout_Instruction_Type.Rack:  # Not a rack block so add it to the beginning of the clean blocks
                clean_blocks.insert(0, op_block)
        full_clean_blocks: list[list[Knitout_Diff_Line]] = op_blocks[:i]
        full_clean_blocks.extend(clean_blocks)
        return full_clean_blocks

    @staticmethod
    def _block_operations_by_direction(op_blocks: list[list[Knitout_Diff_Line]]) -> list[list[Knitout_Diff_Line]]:
        blocks_by_direction: list[list[Knitout_Diff_Line]] = []

        def _get_op_direction(diff_line: Knitout_Diff_Line) -> None | Carriage_Pass_Direction:
            if isinstance(diff_line.instruction, Needle_Instruction) and diff_line.instruction.has_direction:
                return diff_line.instruction.direction
            else:
                return None

        for op_block in op_blocks:
            needles_in_block = set()
            first_op = op_block[0]
            current_direction = _get_op_direction(first_op)
            if isinstance(first_op.instruction, Needle_Instruction):
                needles_in_block.add(first_op.instruction.needle)
            current_block = [first_op]
            for op in op_block[1:]:
                op_dir = _get_op_direction(op)
                if (op_dir != current_direction or  # The direction changed, so switch to new block
                        (isinstance(op.instruction, Needle_Instruction) and op.instruction.needle in needles_in_block)):  # A needle re-occurred, so this is a new carriage pass.
                    blocks_by_direction.append(current_block)
                    current_block = [op]
                    current_direction = op_dir
                    needles_in_block = set()
                    if isinstance(op.instruction, Needle_Instruction):
                        needles_in_block.add(op.instruction.needle)
                else:
                    current_block.append(op)
            blocks_by_direction.append(current_block)
        return blocks_by_direction

    @staticmethod
    def _reduce_racks(op_blocks: list[list[Knitout_Diff_Line]]) -> list[list[Knitout_Diff_Line]]:
        current_rack = 0.0
        reduced_rack_blocks: list[list[Knitout_Diff_Line]] = []
        for block in op_blocks:
            if block[-1].operation is Knitout_Instruction_Type.Rack:  # rack block
                last_rack = block[-1].instruction
                assert isinstance(last_rack, Rack_Instruction)
                block_rack = last_rack.rack_value
                if block_rack != current_rack:
                    current_rack = block_rack
                    reduced_rack_blocks.append([block[-1]])
            else:
                reduced_rack_blocks.append(block)
        if len(reduced_rack_blocks) > 0 and reduced_rack_blocks[-1][-1].operation is Knitout_Instruction_Type.Rack:
            reduced_rack_blocks.pop()  # remove extraneous last rack.
        return reduced_rack_blocks

    @staticmethod
    def _merge_blocks(op_blocks: list[list[Knitout_Diff_Line]]) -> list[list[Knitout_Diff_Line]]:
        merged_blocks: list[list[Knitout_Diff_Line]] = [op_blocks[0]]
        for block in op_blocks[1:]:
            both_xfers = merged_blocks[-1][0].operation is Knitout_Instruction_Type.Xfer and block[0].operation is Knitout_Instruction_Type.Xfer
            both_racks = merged_blocks[-1][0].operation is Knitout_Instruction_Type.Rack and block[0].operation is Knitout_Instruction_Type.Rack
            if both_xfers or both_racks:
                merged_blocks[-1].extend(block)
            else:
                merged_blocks.append(block)
        return merged_blocks

    def get_diff_results(self) -> Knitout_Diff_Result:
        """
        Returns:
            DiffResult object containing comparison results
        """

        return Knitout_Diff_Result(self.file1_path, self.file2_path, self.header_diffs, self.operation_diffs)

    def _clear_meaningless_content(self, lines: list[Knitout_Diff_Line]) -> list[Knitout_Diff_Line]:
        """
        Args:
            lines: The lines to clear of meaninglessness content.
        Returns:
            The set of lines cleared of meaninglessness content such as comments and version lines.
        """
        meaningful = []
        for line in lines:
            if self.ignore_comments:
                line.comment = None
            if line.is_header:  # Always include  headers
                meaningful.append(line)
            elif line.operation is not None:  # Include lines with operations
                meaningful.append(line)
            elif not self.ignore_version and line.is_version_line:  # include version lines if not ignoring
                meaningful.append(line)
            elif not self.ignore_comments and line.only_comment:  # include comments if not ignoring
                meaningful.append(line)

        return meaningful

    @staticmethod
    def _separate_headers_operations(lines: list[Knitout_Diff_Line]) -> tuple[list[Knitout_Diff_Line], list[Knitout_Diff_Line]]:
        """Separate header lines from operation lines."""
        headers = []
        operations = []

        for line in lines:
            if line.is_version_line or line.is_header:
                headers.append(line)
            else:
                operations.append(line)

        return headers, operations

    def _compare_headers(self) -> list[dict]:
        """Compare header sections of two files."""
        diffs = []

        # Convert headers to dictionaries for easier comparison
        headers1_dict = self._headers_to_dict(self._headers1)
        headers2_dict = self._headers_to_dict(self._headers2)

        # Find differences
        all_keys = set(headers1_dict.keys()) | set(headers2_dict.keys())

        for key in all_keys:
            if key in headers1_dict:
                head1 = headers1_dict[key]
                assert isinstance(head1.instruction, Knitout_Header_Line)
                val1 = head1.instruction.header_value
            else:
                head1 = None
                val1 = None
            if key in headers2_dict:
                head2 = headers2_dict[key]
                assert isinstance(head2.instruction, Knitout_Header_Line)
                val2 = head2.instruction.header_value
            else:
                head2 = None
                val2 = None
            if val1 != val2:
                diffs.append({
                    'type': DiffType.HEADER,
                    'key': key,
                    'value1': val1,
                    'value2': val2,
                    'line1': head1.line_number if head1 is not None else None,
                    'line2': head2.line_number if head2 is not None else None
                })

        return diffs

    @staticmethod
    def _headers_to_dict(headers: list[Knitout_Diff_Line]) -> dict[Knitout_Header_Line_Type, Knitout_Diff_Line]:
        """Convert header lines to a dictionary."""
        return {h.instruction.header_type: h for h in headers if isinstance(h.instruction, Knitout_Header_Line)}

    def _compare_operations(self) -> list[Knitout_Difference_Block]:
        """Compare operation sequences of two files."""
        diffs = []
        for block_1, block_2 in zip(self._operations1_blocks, self._operations2_blocks):
            normalized_block1: list[str] = [l.get_normalized_string(ignore_comments=self.ignore_comments) for l in block_1]
            normalized_block2: list[str] = [l.get_normalized_string(ignore_comments=self.ignore_comments) for l in block_2]
            block_diffs = []
            matcher = difflib.SequenceMatcher(None, normalized_block1, normalized_block2)
            for tag, i1, i2, j1, j2 in matcher.get_opcodes():
                if tag == 'equal':
                    continue
                if i1 >= len(block_1):
                    start1 = block_1[-1].line_number + 1
                else:
                    start1 = block_1[i1].line_number
                if i2 >= len(block_1):
                    end1 = block_1[-1].line_number + 1
                else:
                    end1 = block_1[i2].line_number
                if j1 >= len(block_2):
                    start2 = block_2[-1].line_number + 1
                else:
                    start2 = block_2[j1].line_number
                if j2 >= len(block_2):
                    end2 = block_2[-1].line_number + 1
                else:
                    end2 = block_2[j2].line_number
                block_diffs.append(Knitout_Difference_Block(tag, block_1[i1:i2], block_2[j1:j2],
                                                            start1, end1, start2, end2))
            if len(block_diffs) > 0:  # some differences, try rearranging
                block_diff = Knitout_Difference_Block(Knitout_Difference_Block_Tag.replace, block_1, block_2,
                                                      block_1[0].line_number, block_1[-1].line_number, block_2[0].line_number, block_2[-1].line_number)
                if (block_diff.can_be_rearranged and
                        (block_diff.is_transfer_only_block() or block_diff.is_equivalent_all_needle())):
                    diffs.append(block_diff)
                    continue  # add this instead of the original diffs.
            diffs.extend(block_diffs)
        if len(self._operations1_blocks) != len(self._operations2_blocks):
            remaining_ops_1 = []
            for b in self._operations1_blocks[len(self._operations2_blocks):]:
                remaining_ops_1.extend(b)
            remaining_ops_2 = []
            for b in self._operations2_blocks[len(self._operations2_blocks):]:
                remaining_ops_2.extend(b)
            normalized_block1_remainder = [l.get_normalized_string(ignore_comments=self.ignore_comments) for l in remaining_ops_1]
            normalized_block2_remainder = [l.get_normalized_string(ignore_comments=self.ignore_comments) for l in remaining_ops_2]
            matcher = difflib.SequenceMatcher(None, normalized_block1_remainder, normalized_block2_remainder)
            for tag, i1, i2, j1, j2 in matcher.get_opcodes():
                if tag == 'equal':
                    continue
                if i1 >= len(remaining_ops_1):
                    start1 = remaining_ops_1[-1].line_number + 1
                else:
                    start1 = remaining_ops_1[i1].line_number
                if i2 >= len(remaining_ops_1):
                    end1 = remaining_ops_1[-1].line_number + 1
                else:
                    end1 = remaining_ops_1[i2].line_number
                if j1 >= len(remaining_ops_2):
                    start2 = remaining_ops_2[-1].line_number + 1
                else:
                    start2 = remaining_ops_2[j1].line_number
                if j2 >= len(remaining_ops_2):
                    end2 = remaining_ops_2[-1].line_number + 1
                else:
                    end2 = remaining_ops_2[j2].line_number
                diffs.append(Knitout_Difference_Block(tag, remaining_ops_1[i1:i2], remaining_ops_2[j1:j2],
                                                      start1, end1, start2, end2))
        return diffs

    @staticmethod
    def _normalize_operation(line: Knitout_Diff_Line) -> str:
        """Normalize an operation for comparison."""
        if len(line.tokens) == 0:
            return ""
        # Join tokens with single spaces
        return " ".join(line.tokens)

    # def _generate_unified_diff(self, file1_path: str, file2_path: str) -> str:
    #     """Generate a unified diff string."""
    #     text1 = [line.get_normalized_string(ignore_comments=self.ignore_comments) for line in self._lines1]
    #     text2 = [line.get_normalized_string(ignore_comments=self.ignore_comments) for line in self._lines2]
    #
    #     diff = difflib.unified_diff(
    #         text1, text2,
    #         fromfile=file1_path,
    #         tofile=file2_path,
    #         lineterm=''
    #     )
    #
    #     return '\n'.join(diff)


def diff_knitout_files(file1_path: str, file2_path: str,
                       ignore_comments: bool = True,
                       ignore_whitespace: bool = True,
                       ignore_version: bool = True,
                       verbose: bool = False,
                       simple_report: bool = False) -> Knitout_Diff_Result:
    """
    Convenience function to diff two knitout files.

    Args:
        file1_path: Path to the first knitout file.
        file2_path: Path to the second knitout file.
        ignore_comments: If True, ignore comment differences (default: True).
        ignore_whitespace: If True, ignore whitespace-only differences (default: True).
        ignore_version: If True, ignore the version line differences (default: True).
        verbose: If True, print detailed output (default: False).
        simple_report: If True, print a simple report if the files are functionally equivalent.

    Returns:
        DiffResult object containing comparison results.
    """
    differ = KnitoutDiffer(file1_path, file2_path, ignore_comments=ignore_comments, ignore_whitespace=ignore_whitespace, ignore_version=ignore_version)
    diff_result = differ.get_diff_results()
    if simple_report:
        diff_result.simple_report()
    if verbose:
        diff_result.verbose_report()

    return diff_result


if __name__ == "__main__":
    import sys

    if len(sys.argv) != 3:
        print("Usage: python knitout_diff.py <file1.k> <file2.k>")
        sys.exit(1)

    file1, file2 = sys.argv[1], sys.argv[2]

    try:
        result = diff_knitout_files(file1, file2, verbose=True)
        result.simple_report()
        if result.are_equivalent:
            sys.exit(0)
        else:
            sys.exit(1)

    except Exception as e:
        print(f"Error: {e}")
        sys.exit(2)
